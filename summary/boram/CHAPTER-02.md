# CH02. 옵저버 패턴

객체들에게 연락 돌리기 

## 옵저버 패턴
![image](https://github.com/you-can-be-ace/headfirst-design-patterns/assets/14108487/1342711d-d1ac-43c1-859c-a76836799d5d)

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
- 주제(신문사)+옵저버(구독) = 옵저버 패턴
- 구조
  - `Subject`
    - 주제를 나타내는 Subject 인터페이스, 옵저버 객체 등록, 삭제, 업데이트 노티 
  - `ConcreteSubject`
    - 옵저버 객체 등록, 삭제, 업데이트 노티 구현 클래스
    - 상태를 설정하고 알아내는 세터/게터 메소드가 들어 있을 수도 있음
  - `Observer`
    - 각 주제마다 여러 개의 Observer가 있을 수 있음
    - 주제의 상태가 바뀌었을 때 호출
  - `ConcreteObserver`
    - Observer 인터페이스만 구현한다면 무엇이든 옵저버 클래스가 될 수 있다.
    - 각 옵저버는 특정 주제에 등록해서 연락 받기 가능 
- one-to-many
  - 옵저버는 주제에 딸려 있으며 주제의 상태가 바뀌면 옵저버에게 정보가 전달됨
  - 주제에 의존적인 성질: 옵저버는 데이터가 변경되었을 때 주제에서 갱신해 주기를 기다리는 입장 
- 확장성
  - Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여 가능
- 느슨한 결합
  - 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모름
  - 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템 구축 가능
  - 객체 사이의 상호의존성을 최소화 할 수 있음 
- 방식은 두가지
  - push : 주제가 데이터를 옵저버에게 보낸다.
  - pull : 옵저버가 주제로부터 필요한 데이터를 끌어다가 쓴다.
  - 풀 방식이 '더 옳은 방식'이라고 간주
- MVC 시간에 다시 만나요. 
