# 옵저버 패턴(Observer Pattern)이란?

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고, 자동으로 내용이 갱신된다.
- 일대다(one-to-many) 의존성을 가진다.

# 옵저버 패턴의 동작원리

- 옵저버라고 하는 구독자 객체들이 주제를 구독하고 있다가 갱신 내용을 전달받는다. (ex. 신문 구독 서비스)
- **주제 객체**
    - 중요한 데이터를 관리한다.
    - 주제 데이터가 바뀌면 새로운 데이터 값이 옵저버에게 전달된다.
- **옵저버 객체**
    - 주제를 구독하고 있다가, 주제 데이터가 바뀌면 갱신 내용을 전달받는다

# 옵저버 패턴의 구조

- 보통 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현한다.
  
![chapter02_1](https://github.com/you-can-be-ace/headfirst-design-patterns/assets/132281360/51e9cf1d-33ab-4606-a6b3-1a3aaa68671e)

- **Subject 인터페이스**
    - 주제를 나타내는 인터페이스
    - 옵저버 등록/탈퇴/노티 역할을 수행한다.
- **Observer 인터페이스**
    - update() 메소드는 주제의 상태가 바뀌었을 때 호출된다.
    - 옵저버 객체는 해당 인터페이스를 반드시 구현해야한다.
- Subject와 Observer는 1:N의 관계를 가진다.

# 옵저버 패턴과 느슨한 결합

### 느슨한 결합(Loose Coupling)

- 객체들이 상호작용할 수는 있지만, 서로를 잘 모르는 관계를 의미한다.
- 느슨한 결합을 활용하면 유연성이 향상된다.

### 옵저버 패턴에서 어떤 방식으로 느슨한 결합을 만들어낼까?

- **주제는 옵저버가 특정 인터페이스(Observer)를 구현한다는 사실만 알고 있다.**
    - 옵저버의 구상 클래스가 무엇인지, 옵저버가 무슨 일을 하는 지 알 필요 없다.
    - 주제는 Observer 인터페이스만 의존하므로, 해당 인터페이스의 구현체가 늘어나도 주제에게는 영향이 가지 않는다.
- 옵저버는 언제든지 새로 추가할 수 있다.
- 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없다.
- 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
- 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않는다.

# 옵저버 패턴 push vs pull

- **push 방식**
    - 주제가 옵저버에게 데이터를 보내는 방식
- **pull 방식**
    - 옵저버가 필요한 데이터만 주제에게서 가져오는 방식
- 일반적으로 pull 방식이 더 ‘옳은’ 방식이라고 간주한다.

# 💡 디자인 원칙

- 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 한다.
