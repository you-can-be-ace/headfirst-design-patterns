# new를 통한 객체 생성의 한계

```java
Duck duck;
if(picnic) duck = new MallardDuck();
else if(hunting) duck = new DecoyDuck();
else if(inBathTub) duck = new RubberDuck();
```

- 인터페이스를 쓰긴 했으나, 그럼에도 구상 클래스의 인스턴스를 만들어야 하므로 유연성이 떨어진다.
- 인스턴스 타입이 컴파일 시점에 결정되므로, 컴파일 전까지는 어떤 타입의 인스턴스가 생성될 지 알 수 없다.

### 인터페이스와 구상 클래스

- 인터페이스를 바탕으로 만들어진 코드는 **다형성**을 제공한다.
- 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를 변경해야 한다. (**OCP 위반**)

### 팩토리적 사고로 러프하게 해결 방안 생각해보기

- 객체를 생성하는 부분만 별도의 **팩토리 메소드**로 분리해둔다.
- 그렇게 되면 옵션이 추가되고 구현이 변경되어도 여기저기 고칠 필요 없이 팩토리 메소드만 수정하면 된다.

# 🥉 Simple Factory
![제목 없는 다이어그램-1719059968643 drawio](https://github.com/you-can-be-ace/headfirst-design-patterns/assets/132281360/8de215b0-0a34-4c44-ab8c-8fd4b20e0c60)
- 구상 클래스를 직접 참조하는 팩토리 클래스를 별도로 둔다.
- 클라이언트는 구상 클래스를 직접 참조하지 않고 팩토리로부터 인스턴스를 받게 된다.
- 각 피자는 Pizza 인터페이스를 구현해야 하고, 구상 클래스여야 한다.

### 디벨롭하기 (팩토리 메소드 패턴으로 가는 길)

- 여러 개의 팩토리를 두고 싶다!
    - SimplePizzaFactory를 삭제하고, 서로 다른 팩토리를 만들어 PizzaStore에서 적당한 팩토리를 사용하도록 한다.
        - PizzaStore를 추상클래스로 변경하고, `createPizza()`를 추상 메서드로 PizzaStore로 옮긴다.
        - `orderPizza()`는 상속할 수 없도록 final로 선언한다.
        
        → PizzaStore와 Pizza는 완전히 분리되었다.
        

# 🥇 팩토리 메소드 패턴

- 팩토리 메소드 패턴은 서브클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화한다.
- 사용하는 서브클래스에 따라 생산되는 객체 인스턴스가 결정된다.

→ 유연하고 재사용 가능한 패턴

### 추상 팩토리 메소드

```java
abstract Product factoryMethod(String type)
```

- 서브클래스가 객체 생성을 책임지도록 하여 슈퍼클래스의 클라이언트 코드와 객체 생성 코드를 분리한다.
- 클라이언트에서 실제로 생성되는 구상 객체가 무엇인지 알 수 없게 만드는 역할도 한다.

# 의존성 뒤집기 원칙(Dependency Inversion Principle)

- 고수준 구성 요소가 저수준 구성 요소에 의존하면 안되며, 항상 추상화에 의존하게 만들어야 한다.
    - 고수준 구성 요소는 다른 저수준 구성 요소에 의해 정의되는 행동이 들어있는 구성 요소를 뜻한다.
        
        > PizzaStore는 고수준, Pizza는 저수준 구성요소
        > 
    - 추상 클래스나 인터페이스같이 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.
- 팩토리 메소드 패턴은 DI 원칙을 준수하는 방법 중 하나이다.

### DI 원칙을 지키는 방법

- 변수에 구상 클래스의 레퍼런스를 저장하지 않는다.
- 구상 클래스에서 유도된 클래스를 만들지 않는다.
- 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 않는다.

# 🥇추상 팩토리 패턴

- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공한다.
    - 구상 클래스는 서브클래스에서 만든다.
- 클라이언트와 팩토리에서 생산되는 제품을 분리할 수 있다.

### 팩토리 메소드 패턴 vs 추상 팩토리 패턴

- 둘 다 애플리케이션을 특정 구현으로부터 분리한다.
- 팩토리 메소드 패턴은 **상속**으로, 추상 팩토리 패턴은 **구성(composition)**으로 객체를 만든다.
    - 팩토리 메소드 패턴
        - 서브클래스가 객체를 만든다.
        - 클라이언트는 자신이 사용할 추상 형식만 알면 된다.
    - 추상 팩토리 패턴
        - 제품군을 만드는 추상 형식을 제공한다.
        - 제품군이 생산되는 방법은 서브클래스에서 정의한다.
        - 새로운 제품군을 추가할 때는 인터페이스를 변경해야한다.

→ 클라이언트에서 서로 연관된 일련의 제품, 즉 제품군을 만들 땐 추상 팩토리 패턴이 적합하다.

→ 클라이언트 코드와 구상 클래스를 분리시켜야 할 때는 팩토리 메소드 패턴이 적합하다.

# 핵심 정리

- 팩토리를 쓰면 객체 생성을 캡슐화할 수 있다.
- 모든 팩토리 패턴은 애플리케이션의 구상 클래스 의존성을 줄여줌으로써 느슨한 결합을 도와준다.
    - 팩토리 메소드 패턴은 상속을 활용해서 서브클래스가 객체를 생산한다.
    - 추상 팩토리 패턴은 구성을 활용해서 팩토리 인터페이스에서 선언한 메소드에서 객체가 생산된다.
- 의존성 뒤집기 원칙을 따르면 구상 형식 의존을 피하고 추상화를 지향할 수 있다.
- 팩토리는 구상 클래스가 아닌 추상 클래스와 인터페이스에 맞춰 코딩할 수 있게 해주는 강력한 기법이다.
