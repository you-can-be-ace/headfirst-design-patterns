# 문제 상황과 해결 방안

- 오리 시뮬레이션 게임을 상속 구조를 통해 구현하던 개발자는 갑자기 오리가 날 수 있게 해야 한다는 요구사항을 만나게 되는데…

## 잘못된 해결 방법

### 1) 슈퍼클래스 메서드 상속 (❌)

- 서브클래스 내 코드 중복
- 모든 구현체의 행동을 알 수 없음
- 실행 시 행동 변경 불가
- 슈퍼클래스 내 메소드의 코드 변경 시 다른 구현체에게 원치 않은 영향을 끼칠 수 있음

### 2) 인터페이스 설계 (❌)

- 인터페이스 상속을 통해 특정 구현체만 유관 기능을 갖도록 할 수 있으나 코드 재사용 불가
- 구현체가 구현 시 각 기능을 다르게 구현 가능

⇒ 변하지 않는 소프트웨어는 없다. 시간이 지남에 따라 변화하고 성장해야 한다.

# ⭐ 핵심 디자인 원칙

- 애플리케이션에서 변경되는 부분을 찾아 캡슐화하여 변하지 않는 부분과 분리
    - 이렇게 할 경우 이후 변경 시 변경되지 않는 부분에는 영향을 미치지 않게 할 수 있음
- 구현보다는 인터페이스(상위 형식)에 맞춰 프로그래밍
- 상속보다는 구성을 활용한다.

# 바뀌는 부분과 그렇지 않은 부분 분리하기

- `fly()`와 `quack()`은 `Duck` 클래스 내 오리 종류에 따라 달라지는 부분
    - 2개 메소드를 꺼내 각 행동을 나타낼 클래스 집합 생성 필요

# 오리의 행동 디자인 및 구현

## 디자인

- 각 행동은 인터페이스(`FlyBehavior`, `QuackBehavior`)로 표현, 인터페이스를 사용하여 행동 구현
- 해당 인터페이스의 행동 구현은 `Duck` 서브 클래스에 국한되지 않음
- 실제 실행 시 쓰이는 객체가 코드에 고정되지 않도록 상위 형식에 맞춰 다형성 활용

## 구현

- `FlyBehavior`
    - `FlyWithWings` : 날개로 낢
    - `FlyNoWay` : 날 수 없음
- `QuackBehavior`
    - `Quack` : 꽥꽥
    - `Squeak` : 고무 오리의 삑삑
    - `MuteQuack` : 소리를 낼 수 없는 경우

⇒ 다른 형식의 객체에서도 나는 행동과 꽥꽥거리는 행동 재사용 가능

⇒ 기존의 행동 클래스를 수정하거나 날아다니는 Duck 클래스를 건드리지 않고도 행동 추가 가능

# 오리 행동 통합하기

```java
public abstract class Duck {
	QuackBehavior quackBehavior;
	
	public void performQuack() {
		quackBehavior.quack();
	}
}
```

```java
public class Mallardduck extends Duck {
	
	public MallardDuck() {
		quackBehavior = new Quack(); // 아직은 구현체에 의존
		flyBehavior = new FlyWithWings();
	}
	
	public void display() {
		System.out.println("저는 물오리입니다.");
	}
}
```

# 동적으로 행동 지정하기

```java
public void setFlyBehavior(FlyBehavior fb) {
	flyBehavior = fb;
}

public void setQuackBehavior(QuackBehavior qb) {
	quackBehavior = qb;
}
```

- 실행 중 오리의 행동을 바꾸고 싶으면 원하는 행동에 해당하는 Duck의 Setter 메소드를 호출

# 두 클래스를 합치는 방법

- 구성(composition)
    - A에는 B가 있음
    - 한 클래스 내 다른 객체가 포함되어 있는 것을 의미

# 전략 패턴

여태까지 배웠던 방법이 바로 전략 패턴..!

- 알고리즘군을 정의하고 캡슐화하여 각각의 알고리즘군을 수정해서 쓸 수 있게 함
- 전략 패턴 사용 시 클라이언트로부터 알고리즘을 분리해 독립적으로 변경 가능

# 디자인 패턴? 🤔

- 개발자 사이에서 서로 모두 이해할 수 있는 용어 및 디자인 문제의 보편적인 해결책 제공
- 객체 수준에서의 생각이 아닌 패턴 수준에서 생각할 수 있어 아키텍처를 생각하는 수준도 향상
- 라이브러리보다 높은 수준에 해당, 특정 애플리케이션에 맞게 적용하는 건 개발자의 몫
- 디자인은 예술, 객체지향 원칙만 안다고 전문가가 될 수 있지 않음
- 검증 받은 객체지향 경험의 산물
