# 옵저버 패턴의 정의

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고,
    
    자동으로 내용이 갱신되는 방식으로 일대다 의존성 정의
    
- 출판-구독(Publish-Subscribe) 패턴과 유사하지만 다름
    
    

⇒ 보통 주제(Subject) 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 보통 구현

# 옵저버 패턴 구현 방안

## 푸시(Push)

- 주제가 옵저버로 데이터를 보내는 방안
- 주제가 옵저버에 전달해야 할 데이터 추가 시 옵저버 인터페이스의 시그니처를 변경해야 할 수도 있음

## 풀(Pull) ✅

- 이벤트 발생 시 옵저버가 주제로부터 데이터를 당겨오는 방식
- 보다 유연하고 확장성이 있음

<aside>
💡 **Q. 주제에서 옵저버로 알림이 가는 순서를 정해야 하나요?**
A. Observer를 알림 순서에 의존하지 말라는 JDK 권고가 있음

</aside>

# 옵저버 패턴의 구조
![image](https://github.com/you-can-be-ace/headfirst-design-patterns/assets/16659000/ae7f37f2-4bb8-4fd7-b611-804b206f012a)

- 주제 역할을 하는 구상 클래스는 Subject 인터페이스 구현
- 각 주제마다 여러 개의 옵저버 존재 가능
- `Observer` 인터페이스만 구현한다면 무엇이든 옵저버 클래스가 될 수 있음

# 느슨한 결합의 위력

`느슨한 결합` : 객체들이 상호작용 가능하지만 서로를 완전히 잘 알지 못하는 관계

주제는 옵저버가 특정 인터페이스를 구현한다는 사실만 알고 있음

새로운 형식의 옵저버 추가 시에도 주제 변경 불필요, 서로 달라져도 영향을 미치지 않음

**⇒ 주제와 옵저버는 느슨한 결합으로 인해 서로 독립적으로 재사용 가능**

# ⭐ 핵심 디자인 원칙

- 상호 작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야 함
    
    ⇒ 느슨한 결합 사용 시 상호 의존성을 최소화하여 유연한 시스템 구축 가능
    

# 기상 스테이션 설계
![image](https://github.com/you-can-be-ace/headfirst-design-patterns/assets/16659000/8ad383e9-2fb9-491e-ac7a-49c0c0acd792)


# 자바의 옵저버 패턴

- 자바에서도 `Observer`, `Observable` 인터페이스를 지원함으로써
    
    편리하게 옵저버 패턴을 구현하도록 하였으나 실제 사용자들이 직접 인터페이스를 구현하는 
    
    일이 늘어나며 JDK 9 에서 Deprecated 됨
