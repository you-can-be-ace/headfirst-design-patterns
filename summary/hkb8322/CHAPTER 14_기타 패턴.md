# 1️⃣ 브리지 패턴

## 개요

- 구현과 추상화를 변경해야 할 경우 사용
- 추상화된 부분과 구현 부분을 서로 다른 클래스 계층구조로 분리하여 변경 가능

## 활용법

- 여러 플랫폼에서 사용해아 하는 그래픽스와 윈도우 처리 시스템에서 사용
- 인터페이스와 실제 구현부를 서로 다른 방식으로 변경해야 할 때 사용

## 장점

- 구현과 인터페이스를 완전 결합하지 않아 구현과 추상화 분리 가능
- 추상화된 부분과 실제 구현 부분을 독립적으로 확장 가능
- 추상화 부분을 구현한 구상 클래스가 바뀌어도 클라이언트엔 영향 없음

## 단점

- 디자인 복잡도 증가

## 예제

[[디자인패턴/Design Pattern] Bridge Pattern / 브리지 패턴](https://lee1535.tistory.com/102)

# 2️⃣ 빌더 패턴

## 개요

- 제품을 여러 단계로 나눠서 만들도록 제품 생성 단계를 캡슐화하고 싶을 경우 사용
- 반복자 패턴이 반복 작업을 별도의 객체로 캡슐화하는 것처럼 유사한 패턴 사용

## 활용법

- 복합 객체 구조를 구축하는 용도로 쓰임

## 장점

- 복합 객체 생성 과정 캡슐화
- 여러 단계와 다양한 절차를 거쳐 객체 생성 가능
- 제품 내부 구조를 클라이언트로부터 보호 가능
- 클라이언트는 추상 인터페이스만 볼 수 있기 때문에 구현부 쉽게 변경 가능

## 단점

- 팩토리를 사용할 때보다 객체 생성 시 클라이언트에 관해 더 많이 알아야 함

# 3️⃣ 책임 연쇄 패턴

## 개요

- 1개의 요청을 2개 이상의 객체에서 처리 시 사용
- 주어진 요청을 검토하는 객체 사슬 생성
    - 사슬 속에 속해 있는 각 객체는 요청을 검사해서 처리하거나 다른 객체에게 넘김

## 활용법

- 윈도우 시스템의 이벤트 처리에 사용

## 장점

- 요청 발송과 수신을 분리할 수 있음
- 객체는  사슬 구조를 몰라도 되고 레퍼런스를 가지지 않으므로 단순하게 설계 가능
- 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가/제거

## 단점

- 요청이 반드시 수행된다는 보장이 없음
- 실행 시 과정을 살펴보거나 디버깅하기 어려움

# 4️⃣ 플라이웨이트 패턴

## 개요

- 어떤 클래스의 인스턴스 하나로 여러 개의 가상 인스턴스를 제공하고자 할 때 사용

## 활용법

- 어떤 클래스의 인스턴스가 아주 많이 필요하지만 모두 동일한 방식으로 제어해야 할 때 사용

## 장점

- 실행 시 객체 인스턴스 개수를 줄여 메모리를 절약할 수 있음
- 여러 가상 객체의 상태를 한 곳에 모아둘 수 있음

## 단점

- 특정 인스턴스만 다른 인스턴스와 다르게 행동하게 할 수 없음

# 5️⃣ 인터프리터 패턴

## 개요

- 어떤 언어의 인터프리터 구현 시 사용

## 활용법

- 문법과 구문을 번역하는 인터프리터 클래스 기반으로 간단한 언어 정의
- 효율보다 단순하고 간단하게 문법을 만드는 것이 더 중요한 경우 유용
- 스크립트 언어와 프로그래밍 언어에서 모두 쓸 수 있음

## 장점

- 문법을 클래스로 표현해 쉽게 언어 구현 가능
- 문법이 클래스로 표현되므로 언어를 쉽게 변경하거나 확장 가능
- 클래스 구조에 메소드만 추가하면 프로그램을 해석하는 기본 기능 외 신규 기능 추가 가능

## 단점

- 문법 규칙 개수가 많아지면 아주 복잡해짐
    - 그렇다면 파서나 컴파일러 생성기를 사용하는 것이 나음

# 6️⃣ 중재자 패턴

## 개요

- 서로 관련된 객체 사이 복잡한 통신과 제어를 한 곳에 집중시키고자 할 때 사용
- 객체 상태가 바뀔 때마다 중재자에게 알려줌
- 객체는 중재자에서 보낸 요청에 응답

## 활용법

- 서로 연관된 GUI 구성 요소를 관리하는 용도로 많이 쓰임

## 장점

- 시스템과 객체를 분리함으로써 재사용성을 획기적으로 향상
- 제어 로직을 한 군데 모아두어 관리하기 수월
- 시스템에 들어 있는 객체 사이 오가는 메시지 감소 및 단순화

## 단점

- 디자인을 잘 하지 못하면 중재자 객체가 너무 복잡해질 수 있음

# 7️⃣ 메멘토 패턴

## 개요

- 객체를 이전 상태로 복구해야 할 때 사용
- 아래 목적 존재
    - 시스템에서 핵심적인 기능을 담당하는 객체의 상태 저장
    - 핵심적인 객체의 캡슐화 유지

## 활용법

- 상태 저장에 사용
- 자바에서는 상태 저장 시 직렬화를 사용하는 것이 좋음

## 장점

- 저장된 상태를 핵심 객체와는 다른 별도 객체에 보관 가능하여 안전
- 핵심 객체의 데이터를 캡슐화된 상태로 유지 가능
- 복구 기능 구현 유리

## 단점

- 상태 저장/복구에 오랜 시간 소요될 수 있음

# 8️⃣ 프로토타입 패턴

## 개요

- 어떤 클래스의 인스턴스 생성 시 자원과 시간이 많이 들거나 복잡할 경우 사용
- 기존 인스턴스를 복사하여 새로운 인스턴스 생성

## 활용법

- 시스템에서 복잡한 클래스 계층 구조에 파묻힌 다양한 형식의 인스턴스를 생성할 때 유용

## 장점

- 클라이언트가 인스턴스 생성 과정을 모름
- 클라이언트는 구체적인 형식을 몰라도 객체 생성 가능
- 상황에 따라 객체 생성보다 복사가 더 효율적

## 단점

- 때때로 객체의 복사본을 만드는 일이 매우 복잡


# 9️⃣ 비지터 패턴

## 개요

- 다양한 객체에 기능 추가 시 캡슐화가 중요하지 않은 경우 사용
- 컴포지트 패턴 내 복합 객체 내 전체 객체에 접근하는 트래버서와 함께 사용
- 비지터 객체에서 복합 객체 내 모든 객체 대상으로 작업 처리를 도와줌

## 장점

- 구조를 변경하지 않으면서도 복합 객체 구조에 신규 기능 추가 가능
- 비교적 손쉽게 기능 추가 가능
- 비지터가 수행하는 기능과 관련된 코드를 한 곳에 모아 둘 수 있음

## 단점

- 비지터를 사용하면 복합 클래스의 캡슐화가 깨짐
- 컬렉션 내 모든 항목에 접근하는 트래버서가 있으므로 복합 구조를 변경하기 어려워짐
