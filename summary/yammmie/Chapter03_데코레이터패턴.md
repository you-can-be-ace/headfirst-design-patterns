# 데코레이터 패턴 Decorator Pattern

- 객체에 추가 요소를 동적으로 더할 수 있음
- 데코레이터를 사용하면 서브클래스를 만들 때마다 훨씬 유연하게 기능 확장 가능

<br><br>

## OCP(Open-Closed Principle)

> **📍 디자인 원칙**

클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.
> 
- 옵저버 패턴과 같이 주제에 코드를 추가하지 않으면서 확장할 수 있도록 할 것
- 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용할 것
    - 무조건 OCP를 적용할 경우 필요 이상으로 코드가 복잡해지는 부작용 발생

<br><br>

## 구조

<img width="664" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/36028fa6-f4b6-47a7-b225-cbf2d56ff192">

<br>

### Component

- 각 구성 요소는 직접 쓰일 수도 있고 데코레이터에 감싸여 쓰일 수도 있음

<br>

### ConcreteComponent

- 새로운 행동을 동적으로 추가

<br>

### Decorator

- 각 데코레이터 안에는 `Component` 객체가 들어있음
    
    → 구성 요소의 레퍼런스를 포함한 인스턴스 변수
    
- 자신이 장식할 구성 요소와 같은 인터페이스 또는 추상 클래스를 구현함
- `Component`의 상태 확장 가능

<br>

### ConcreteDecorator

- 데코레이터가 감싸고 있는 `Component` 객체용 인스턴스 변수가 있음
- 새로운 메소드 추가 가능
    - 일반적으로 새로운 메소드 추가하는 대신 `Component`에 원래 있던 메소드를 별도의 작업으로 처리해서 새로운 기능 추가함
- `Component`를 감싸 주는 래퍼클래스라고 봐도 무방

<br><br>

## 데코레이터 패턴 적용

<img width="728" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/8d4045ea-058e-41c1-9e1d-1630c3dfe14e">

- `ConcreteComponent`인 `DarkRoast` 객체에서 시작
- 고객이 모카를 추가했으므로 `Mocha` 객체를 생성하고 `DarkRoast` 객체를 감쌈
- 가격을 구할 때는 가장 바깥쪽에 있는 데코레이터인 `Whip`의 `cost()`를 호출하면 그 객체가 장식하고 있는 `DarkRoast` 객체에게 가격 계산을 위임함
    - 가격이 구해지고 나면 계산된 가격에 휘핑크림의 가격을 더한 다음 그 결과값을 리턴함

<br><br>

## 특징

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같음
    - 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 무방
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있음
- **데코레이터는 자신이 장식하고 있는 개체에게 어떤 행동을 위임하는 일 말고도 추가 작업 수행 가능**
- 객체는 언제든지 감쌀 수 있으므로 실행 중에 필요한 데코레이터 마음대로 적용 가능
- 구상 구성 요소로 어떤 작업을 처리하는 코드에 데코레이터 패턴 적용하면 코드가 제대로 작동하지 않음
    - 추상 구성 요소로 돌아가는 코드에는 제대로 작동
- 실제로는 팩토리나 빌더 같은 패턴으로 데코레이터 만들고 사용함
- 여러 단계의 데코레이터를 파고 들어가서 어떤 작업을 해야 한다면 데코레이터 패턴이 만들어진 의도에 어긋남

<br><br>

## 예시: 자바 I/O

<img width="857" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/39c4f185-f194-4514-ba04-a2c02f9d58aa">

- 자바 I/O 라이브러리는 `FileInputStream`, `StringBufferInputStream`, `ByteArrayInputStream` 등 다양한 구성 요소 제공
- `FileInputStream`에 입력을 미리 읽어 더 빠르게 처리하는 버퍼링 기능과 zip 파일에서 데이터 읽어올 때 항목을 읽는 기능을 더해줌

<br><br>

## 핵심 정리

- 데코레이터 패턴은 구상 구성 요소를 감싸주는 데코레이터를 사용함
- 데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영함
- 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장함
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없음
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없음
    - 클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외
- 자잘한 객체가 많이 추가되고, 데코레이터를 많이 사용하면 코드가 필요 이상으로 복잡해짐
