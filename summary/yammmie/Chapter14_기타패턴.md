# 기타 패턴

<br>

## 브리지 패턴 Bridge Pattern

<img width="899" alt="image" src="https://github.com/user-attachments/assets/1f9dc4c0-8fd7-40d7-b513-6d43a82929e5">

- 추상화된 부분과 구현 부분을 서로 다른 클래스 계층구조로 분리해서 그 둘 모두 변경 가능
- 리모콘을 나타내는 부분과 다른 TV를 나타내는 부분을 브리지로 연결했으므로 서로 독립적으로 변경 가능

<br>

### 장점

- 구현과 인터페이스를 완전히 결합하지 않았으므로 구현과 추상화 부분 분리 가능
- 추상화된 부분과 실제 구현 부분 독립적으로 확장 가능
- 추상화된 부분을 구현한 구상 클래스가 바뀌어도 클라이언트에는 영향 X

<br>

### 활용법과 단점

- 여러 플랫폼에서 사용해야 하는 그래픽스와 윈도우 처리 시스템에서 유용
- 인터페이스와 실제 구현할 부분을 서로 다른 방식으로 변경해야 할 때 유용
- 디자인이 복잡해짐

<br><br>

## 빌더 패턴 Builder Pattern

<img width="877" alt="image" src="https://github.com/user-attachments/assets/dfc69498-2f2d-4c00-8ae5-356e3dfea889">

<img width="892" alt="image" src="https://github.com/user-attachments/assets/f784a134-4f76-4109-ae49-9591f57b0fbd">

- 제품을 여러 단계로 나눠서 만들도록 제품 생산 단계를 캡슐화하고 싶을 때 사용
- 클라이언트가 몇 단계에 걸쳐서 요청하고 `getVacationPlanner()` 메소드를 호출해서 완성된 객체를 가져옴

<br>

### 장점

- 복합 객체 생성 과정을 캡슐화함
- 여러 단계와 다양한 절차를 거쳐 객체를 만들 수 있음 (팩토리는 한 단계에서 모든 걸 처리)
- 제품 내부 구조를 클라이언트로부터 보호 가능
- 클라이언트는 추상 인터페이스만 볼 수 있으므로 제품 구현한 코드를 쉽게 변경 가능

<br>

### 활용법과 단점

- 복합 객체 구조를 구축하는 용도로 많이 사용
- 팩토리를 사용할 때보다 객체 만들 때 클라이언트에 관해 더 많이 알아야 함

<br><br>

## 책임 연쇄 패턴 Chain of Responsibility Pattern

<img width="857" alt="image" src="https://github.com/user-attachments/assets/15e160d7-2910-4650-bc48-20754d08ea9f">

- 1개의 요청을 2개 이상의 객체에서 처리해야 할 때 사용
- 주어진 요청을 검토하는 객체 사슬을 생성하고, 그 사슬에 속해 핸들러 역할을 하는 각 객체는 자기가 받은 요청을 검사해서 직접 처리하거나 사슬에 들어있는 다른 객체에게 넘김

<br>

### 장점

- 요청을 보낸 쪽과 받는 쪽 분리 가능
- 객체는 사슬의 구조를 몰라도 되고, 그 사슬에 들어있는 다른 객체의 직접적인 레퍼런스를 가질 필요도 없음 → 객체를 단순하게 만들 수 있음
- 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가하거나 제거 가능

<br>

### 활용법과 단점

- 윈도우 시스템에서 마우스 클릭과 키보드 이벤트를 처리할 때 흔히 사용
- 요청이 반드시 수행된다는 보장이 없음 → 사슬 끝까지 갔는데도 처리되지 않을 수 있음
- 실행 시 과정을 살펴보거나 디버깅하기 힘듦

<br><br>

## 플라이웨이트 패턴 Flyweight Pattern

<img width="857" alt="image" src="https://github.com/user-attachments/assets/064afdfa-0ace-4d2c-836a-b255749a2338">

- 어떤 클래스의 인스턴스 하나로 여러 개의 ‘가상 인스턴스’를 제공하고 싶을 때 사용
- 실행 중 느려지지 않도록 `Tree` 인스턴스는 하나만 만들고, 모든 나무의 상태를 클라이언트 객체가 관리하도록 함

<br>

### 장점

- 실행 시 객체 인스턴스의 개수를 줄여서 메모리 절약 가능
- 여러 ‘가상’ 객체의 상태를 한곳에 모아 둘 수 있음

<br>

### 활용법과 단점

- 어떤 클래스의 인스턴스가 아주 많이 필요하지만 모두 똑같은 방식으로 제어해야 할 때 유용
- 특정 인스턴스만 다른 인스턴스와 다르게 행동할 수 없음

<br><br>

## 인터프리터 패턴 Interpreter Pattern

<img width="897" alt="image" src="https://github.com/user-attachments/assets/ae8b2eb8-f4f9-47d9-846e-cf5c63eae519">

- 어떤 언어의 인터프리터 만들 때 사용
- 문법과 구문을 번역하는 인터프리터 클래스를 기반으로 간단한 언어를 정의함
- 언어에 속하는 규칙을 나타내는 클래스를 사용해서 언어를 표현함

<br>

### 장점

- 문법을 클래스로 표현해서 쉽게 언어 구현 가능
- 언어를 쉽게 변경되거나 확장 가능
- 클래스 구조에 메소드만 추가하면 예쁘게 출력하는 기능 같은 새로운 기능 추가 가능

<br>

### 활용법과 단점

- 간단한 언어를 구현할 때 인터프리터 패턴이 유용
- 효율보다는 단순하고 간단하게 문법을 만드는 것이 더 중요한 경우 유용
- 스크립트 언어와 프로그래밍 언어에서 모두 사용 가능
- 문법 규칙의 개수가 많아지면 아주 복잡해짐 → 파서나 컴파일러 생성기 사용하는 것이 나음

<br><br>

## 중재자 패턴 Mediator Pattern

<img width="897" alt="image" src="https://github.com/user-attachments/assets/a7667051-3f77-48c9-ac27-1fbad720afd6">

- 서로 관련된 객체 사이의 복잡한 통신과 제어를 한곳으로 집중하고 싶을 때 사용
- 중재자 추가 전에는 모든 객체가 다른 객체와 서로 알고 있어야 했음
- 중재자에는 모든 시스템 제어하는 로직 들어있음 → 가전제품에 새로운 규칙을 추가하거나 새로운 가전제품을 추가해도 중재자만 수정하면 됨

<br>

### 장점

- 시스템과 객체를 분리함으로써 재사용성을 획기적으로 향상시킬 수 있음
- 제어 로직을 한 군데 모아놨으므로 관리하기 수월함
- 시스템에 들어있는 객체 사이에서 오가는 메시지를 확 줄이고 단순화 가능

<br>

### 활용법과 단점

- 서로 연관된 GUI 구성 요소를 관리하는 용도로 많이 사용
- 디자인을 잘 하지 못하면 중재자 객체가 너무 복잡해질 수 있음

<br><br>

## 메멘토 패턴

<img width="646" alt="image" src="https://github.com/user-attachments/assets/46fba367-1e8c-4610-af4c-3b3551deb312">

- 객체를 이전의 상태로 복구해야 할 때 사용
- 목적: 시스템에서 핵심적인 기능을 담당하는 객체의 상태 저장, 핵심적인 객체의 캡슐화 유지
- 상태를 따로 저장하는 객체를 메멘토 객체라고 부름

<br>

### 장점

- 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관할 수 있어 안전
- 핵심 객체의 데이터를 계속해서 캡슐화된 상태로 유지 가능
- 복구 기능을 구현하기 쉬움

<br>

### 활용법과 단점

- 메멘토 객체를 써서 상태를 저장함
- 자바 시스템에서는 시스템의 상태를 저장할 때 직렬화를 사용하는 것이 좋음
- 상태를 저장하고 복구하는 데 시간이 오래 걸릴 수 있음

<br><br>

## 프로토타입 패턴 Prototype Pattern

<img width="781" alt="image" src="https://github.com/user-attachments/assets/e2efc3fd-ac98-419e-8406-000a007e6e05">

- 어떤 클래스의 인스턴스를 만들 때 자원과 시간이 많이 들거나 복잡할 때 사용
- 기존 인스턴스를 복사하기만 해도 새로운 인스턴스 생성 가능
    - 자바에서는 clone() 메소드를 사용하거나 역직렬화하면 됨
- 클라이언트 코드에서 어떤 인스턴스를 만드는지 전혀 모르는 상태에서도 새로운 인스턴스 생성 가능

<br>

### 장점

- 클라이언트는 새로운 인스턴스를 만드는 과정 몰라도 됨
- 클라이언트는 구체적인 형식을 몰라도 객체 생성 가능
- 상황에 따라서 객체를 새로 생성하는 것보다 객체를 복사하는 것이 더 효율적일 수 있음

<br>

### 활용법과 단점

- 시스템에서 복잡한 클래스 계층구조에 파묻혀 있는 다양한 형식의 객체 인스턴스를 만들어야 할 때 유용
- 때때로 객체의 복사본을 만드는 일이 매우 복잡할 수 있음

<br><br>

## 비지터 패턴 Visitor Pattern

![Uploading image.png…]()

- 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않을 때 사용
- 비지터 객체는 트래버서(Traverser) 객체와 함께 돌아감
    - 트래버서는 컴포지트 패턴을 쓸 때, 복합 객체 내에 속해 있는 모든 객체에 접근하는 일을 도와주는 역할
- 클라이언트는 비지터에게 각 상태에 맞는 다양한 작업을 처리하도록 요구 가능
- 새로운 기능이 필요할 때 비지터만 수정하면 됨

<br>

### 장점

- 구조를 변경하지 않으면서 복합 객체 구조에 손쉽게 새로운 기능 추가 가능
- 비지터가 수행하는 기능과 관련된 코드를 한곳에 모아 둘 수 있음

<br>

### 활용법과 단점

- 비지터를 사용하면 복합 클래스의 캡슐화가 깨짐
- 컬렉션 내의 모든 항목에 접근하는 트래버서가 있으므로 복합 구조를 변경하기 더 어려워짐

<br><br>

## 참고

https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS5781398544
